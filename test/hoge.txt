このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)

このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)

このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)


このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)

このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)

このテキストは JavaScript のコールバック地獄に疲れたひとのためのコールバック駆逐術指南書です。対象読者は JavaScript道初段くらいの人です。このテキストを読むと、以下のそれぞれの手段における非同期処理制御の仕組み、利点および欠点がわかるようになるかもしれません。

* コールバック地獄
* jQuery.Deferred
* async.js
* generators
* co
* fibers
* async.ts

## それは『何故人はネストするのか』という話でしょうか？

非同期処理って面倒ですよね。JavaScriptではいわゆる **コールバック地獄** というやつにしばしば陥りがちです。たとえば、Ajax でふたつのファイル hoge.txt と piyo.txt を持ってきて、それらを結合してコンソールに出力したいとします。もし同期的にリモートのファイルを読み込む関数 `get` があるとしたら、次のように書けるはずです。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
console.log(hoge + piyo);
```

でもそんな同期的な関数は JavaScript にはありません(XMLHttpRequest#open には同期的に読み込むオプションもありますが、パフォーマンス上の問題があることから使用は勧められません。Nodeにも同期的なファイル読み込み関数 `fs.readFileSync` がありますが、XHR と同様の理由であまり使用は勧められません)。たとえば、jQuery で非同期でファイルを取得する関数 `$.get` を使ったとしても、素直に書くと次のような悲惨なことになるわけです。

```js:
$.get("hoge.txt", function(hoge){
    $.get("piyo.txt", function(piyo){
        console.log(hoge + piyo);        
    });
});
```

もし非同期だけど直列に処理したいモノが３つ、４つと増えていったとすると、それにしたがってさらにネストは深くなっていきます。あまりネストが深くなるとソースコードが読みづらいので、自分などはたまにネストを押しつぶして次のように書いたりします。

```js:
// こういうパターンを見たら、心のなかで var hoge = $.get("hoge.txt") と読み替える
$.get("hoge.txt", function(hoge){    

// なんだか var piyo = $.get("piyo.txt") に見えてきたぞ……？
$.get("piyo.txt", function(piyo){

// どうみても var nyan = $.get("nyan.txt") ですね
$.get("nyan.txt", function(nyan){

// var myon = $.get("myon.txt") のどこにコールバックが？
$.get("myon.txt", function(myon){

console.log(hoge + piyo + nyan + nyan);        




});});});}); // ←見なかったことにしよう！(＾o＾)b
```

JavaScripter は5重、6重のネストが書けるようになって一人前。熟練した JavaScript 職人は、息をするように20重や30重のネストを書きます。いやそんなことはないです。そして、本当の恐怖はエラー処理をちゃんと書くときに始まります。同期的な処理なら try/catch で囲めばまるごと例外を捕獲できますが、こういう非同期処理だといちいち個別に例外処理しなければなりません。なんとかならないものでしょうか。

## 有害なコールバックを駆除した!!たまたま人と恰好が似ていただけだ!!

でも大丈夫、ちまたで話題の [jQuery.deferred](http://api.jquery.com/category/deferred-object/) を使えば、きっとおしゃれに書けるはず……！

```js:
var hoge;
$.get("hoge.txt")
    .then(function(_hoge){
        hoge = _hoge;
        return $.get("piyo.txt");
    })
    .then(function(piyo){
        console.log(hoge + piyo);        
    });
```

えっ……確かにネストは増えていかないけど、なんかむしろキモさが増してる気が……！だいたい、いったんコールバックの外の変数に待避しないと次のコールバックで参照できないとか、なんかもう根本から破綻してるとしか思えません。これならさっきのネスト地獄のほうがまだわかりやすいレベル。そうか、直列に処理するからいけないんだ。`$.when` を使って並列に処理すれば……。

```js:
$.when($.get("hoge.txt"), $.get("piyo.txt")).then(function(hoge, piyo){
    console.log(hoge[0] + piyo[0]);
});
```

うーん。さっきよりはずっとマシになったかな。なんで結果の `hoge` と `piyo` が配列になってるの？`[0]`とかなんなん？というのはまあ目をつぶるとして、`$.get("hoge")` と `hoge` がやけに離れた位置になってしまいました。同期的に書いていた時には `var hoge = get("hoge");` みたいに一行ごとにまとまっていたのに……。もし必要なファイルが増えていくと、さらに離れ離れになっていって、どれとどれが対応しているのかもはやわからなくなってしまいます。同じような処理を追加しているのに、やけに離れた位置を２箇所づつ編集することになります。

```js:
$.when(
    $.get("hoge.txt"), 
    $.get("piyo.txt"), 
    $.get("nyan.txt"),   // 増えた
    $.get("pong.txt"),   // 増えた
    $.get("myon.txt"),   // 増えた
    $.get("chun.txt")    // 増えた
).then(function(
    hoge, 
    piyo,
    nyan,   // 増えた
    pong,   // 増えた
    myon,   // 増えた
    chun    // 増えた
){
    console.log(hoge[0] + piyo[0] + nyan[0] + pong[0] + myon[0] + chun[0]);
});
```

これが同期的だったら、次にように一行づつ編集して増やせるのに……。

```js:
var hoge = get("hoge.txt");
var piyo = get("piyo.txt");
var nyan = get("nyan.txt");  // 増えた
var pong = get("pong.txt");  // 増えた
var myon = get("myon.txt");  // 増えた
var chun = get("chun.txt");  // 増えた
console.log(hoge + piyo + nyan + pong + myon + chun);
```

また、今回はたまたま hoge.txt の piyo.txt の読み込みは独立しているので `$.when` で並列に処理できますが、もし一方の処理がもう一方に依存している場合、たとえば hoge.txt には別のファイルのパスが書かれていて、次にそのパスのファイルを読まなければならない場合には並列には処理できません。その場合はさっきの書きづらいバージョンに戻るしかありません。

## あのasync.jsは調子に乗りすぎた……いつか私が然るべき報いを

非同期処理のフローを制御するライブラリとしては、[async.js](https://github.com/caolan/async#parallel) というものもあります。async.jsでもjQuery.deferredと似たような形式では書けるのですが、async.jsではさらに次のようも書けたりします。

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt")
},
function(err, results) {
    console.log(results.hoge + results.piyo);
});
```

 `parallel` は `jQuery.when` と同様に並列に非同期処理する関数なのですが、名前と処理のテーブルとしてオブジェクトを渡すことができ、並列処理後に呼ばれるコールバックの引数のオブジェクトには、同名のプロパティで結果が格納されています。おお！わりとおしゃれだ！非同期で得たデータがそれぞれ直接変数に代入されるんじゃなくて `results` というオブジェクトにまとめられてるのはまあ許すとして、なんといっても `hoge: get("hoge.txt")` っていうかんじで `hoge` と `get("hoge.txt")` がすぐとなりにあるのが(・∀・)ｲｲ!! これなら処理がもっと増えていっても自然に追加できる！

```js:
function get(path){
    return function(callback){
        $.get(path).then(function(data){ callback(null, data); });
    };
}

async.parallel({
    hoge: get("hoge.txt"),
    piyo: get("piyo.txt"),
    nyan: get("nyan.txt"),  // 増えた
    pong: get("pong.txt"),  // 増えた
    myon: get("myon.txt"),  // 増えた
    chun: get("chun.txt")   // 増えた
},
function(err, results) {
    console.log(results.hoge + results.piyo + results.nyan + results.pong + results.myon + results.chun);
});
```

だがちょっとまってほしい。`async.parallel` の型ってどうなっているんだろう？『 **いや JavaScript で型とか何いってんのお前？** 』とおっしゃるかもしれませんが、我々のような静的型付け過激派は JavaScript を書いている時でさえ型を意識するのです。そんな我々から見れば、こんな動的な API はまさしく粛清の対象。決して許されるものではありません。

じゃあネスト地獄やjQuery.deferredはどうなんだよといいますと、実はネスト地獄スタイルやjQuery.deferredスタイルは一応ちゃんと静的型付けできるのです。試しにTypeScriptで型注釈をつけてみましょう(TypeScriptのステマ)。

```ts:
declare var $: {
    get(path: string, callback: (data: string)=>void): void;
};

$.get("hoge.txt", function(hoge: string){
    $.get("piyo.txt", function(piyo: string){
        console.log(hoge + piyo);        
    });
});
```

ネスト地獄は型付けという意味に関しては完璧です。一部の隙もありません。で……いや、やっぱりjQuery.deferredは静的型付けできませんでした。`$.when` に複数の引数を渡した場合、何をトチ狂ったのかコールバック関数の引数に `[data, textStatus, jqXHR]` という感じで全然違う型のオブジェクトをひとつの配列に押し込んで返してくるのが原因です。これが配列じゃなくてオブジェクトに入れて返してくるならちゃんとした静的型付けできるのですが……。自分に言わせれば、これはスタイルの問題というより単に jQuery の設計ミスだと思います。従って、jQuery.deferredスタイルも本質的には静的型付け可能、ということにしておきます。

それに対して、先ほどの `async.parallel` の場合では事前にどんなオブジェクトが渡されるかわかりませんから、どうにも静的型付けはできません。やっぱりネスト地獄やjQuery.deferredのほうがマシだったんだ！……いや、やっぱりどっちもどっちです。

## 私の特技はコールバックを削ぎ落とすことです…必要に迫られればいつでも披露します…私のgeneratorsを体験したい方がいれば…どうぞ一番先に近づいて来てください

そういえば次期の JavaScript1.7 では **[generators](http://wiki.ecmascript.org/doku.php?id=harmony:generators)** という機能が導入されそうです。generator があれば、 **yield** というキーワードを使って次のように書けるようになるみたいです(`get` は generator で使えるように適当に定義されているものとします)。

```js:
var generator = (function*(){
    var hoge = yield get("hoge.txt", generator);
    var piyo = yield get("piyo.txt", generator);
    console.log(hoge + piyo);
})();
generator.next();
```

このコードではあくまで直列にファイルを操作しています。ここでいう『直列』というのは、このコードでは hoge.txt を読み込んで、 **それが完了したら** piyo.txt の読み込みを開始しているということです(ちなみにこういうのを『直列』と呼んでいるのはたぶん俺だけです)。でも、この場合別に hoge.txt と piyo.txt の読み込みは並列に行なって構いません。piyo.txt の読み込みをするときにいちいち hoge.txt の読み込みを待っていたら遅くなってしまいます。並列に処理したい場合は次のような感じになるでしょう。くわしくはもっと下の方の完全なコードを参照してください。

```ts:
var generator = (function*(){
    var x = get("hoge.txt", generator);
    var y = get("piyo.txt", generator);
    yield;
    yield;
    console.log(x() + y());
})();
generator.next();
```

並列で処理した結果を受け取るためにちょっと工夫しています。`get` は関数を返すようになっていて、この関数は `yield` から復帰したあとで呼び出すと、並列処理の結果を返すようになっています。

直列、並列いずれについても `generator` という変数が不思議な使われかたをしていて直感的にわかりづらいところがあったり、`get` にいちいち `generator` を渡さなければならないという難点はありますが、非同期処理としてのわかりやすさとしては比較的いい線をいっているように見えます。

他に気をつけるべき点としては、 `yield` の回数をうっかり間違えないようにすることあたりでしょうか。うっかりひとつ多く `yield` を書くと処理がそこでストップしてしまいますし、ひとつでも足りないとすべての非同期処理が完了しないまま先に進んでしまい、上のコードで言うと `y()` が `undefined` になってしまいます。非同期処理ひとつにたいして `yield` ひとつ、という対応関係が保証できないので、常に非同期処理が何個走っているか意識しておく必要があります。

かなり読みやすく直列な処理と並列な処理の書き分けもしやすいものの、おまじないともいえるような注意点がいろいろあるのがネックですし、そもそもこのコードが動く環境がほとんどないのが困ります。

ちなみに、Firefox Nightly で動く完全なテストコードは次のようなものです。本当はXHRで実際にファイルを読むサンプルにしたかったんですが、Firefox のセキュリティ上の制限でローカルファイルが読めないので、代わりに `setTimeout` で非同期な処理をしているつもりにしています。` <any>` に無理矢理感が漂っていますが、これは TypeScript が generator に対応すれば必要なくなるはずです。`yield` は本当はキーワードですが、現時点の TypeScript でコンパイルできるように関数に見せかけてごまかしています。あと、さっきのサンプルコードとは違って `function*(){ ... }` っていう感じに functionキーワードの後ろにアスタリスクが付いていませんが、このあたりの事情については他のgeneratorについての記事を参照してみてください。

```ts:
declare function yield<T>(f: ()=>T): T;

interface Generator {
    send(value: any): void;
    next(): void;
}

declare var StopIteration: new()=>void;

function get(path: string, generator: Generator): ()=>string {
    var value: string;
    setTimeout(()=>{ 
        try{
            value = "[content: " + path + "]";            
            generator.send(value);
        }catch(e){
            if (! (e instanceof StopIteration)) throw e;
        }
    }, 500);
    return ()=>value;
}

var generator: Generator = <any> (()=>{
    // 直列バージョン
    var x: string = yield(get("hoge.txt", generator));
    var y: string = yield(get("piyo.txt", generator));
    console.log(x + y);

    // 並列バージョン
    var w: ()=>string = get("hoge.txt", generator);
    var z: ()=>string = get("piyo.txt", generator);
    yield;
    yield;
    console.log(w() + z());
})();
generator.next();
```

## 彼の持つcoとgeneratorsが組み合わされば、この街の奪還も不可能ではありません!! 人類の栄光を願い、これから死に行くせめてもの間に、coの戦術的価値を説きます!!

generator を利用したもっと格好いいライブラリには [co](https://github.com/visionmedia/co) というものもあります。Node の開発版でしか動かないようで自分はまだ試していないのですが、どうやら次のように書けるようになるみたいです。

```js:
co(function *(){
  var a = yield get('http://google.com');
  var b = yield get('http://yahoo.com');
  var c = yield get('http://cloudup.com');
  console.log(a.status);
  console.log(b.status);
  console.log(c.status);
})

co(function *(){
  var a = get('http://google.com');
  var b = get('http://yahoo.com');
  var c = get('http://cloudup.com');
  var res = yield [a, b, c];
  console.log(res);
})
```

なんと！これまであった問題点がだいたい解決しています。これをみてしまったら、jQuery.deferredは<del>まるでゴミクズ</del>少々力不足のようにも思えます。自分は `get` にも Generator を渡す必要があると思っていたのですが、うまいことやると `get("hoge.txt")` みたいなコードだけで実現できるようです。`yield [a, b, c]` というのも謎で、ここだけちょっと静的型付けとの折り合いがつかなそうです。どうなっているのかはまだよくわかりませんがとにかく凄そうです。

## 寄行種なら、ここに一匹いるがな

Node 環境に限っては、[fibers](https://github.com/laverdet/node-fibers) を使うという選択肢もないことはありません。node-fibers では V8 にネイティブな fiber を追加します。Node限定、しかもどこのNode環境でも使えるとは限りませんが、根本的な解決策ではあります。fiber ならコンソールに出力し、１秒停止し、その後またコンソールに出力するという一連の処理を次のようにとても自然に書くことができるようになります。

```js:
Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
```

構文としては申し分なく、これまで見てきた中ではもっとも扱いやすいといえるでしょう。でも現実は非情です。もちろんブラウザではまったく使えません……。

## 調査兵団に入って……とにかくコールバックをぶっ殺したいです

いろいろな非同期処理の制御の方法を見てきましたが、どうもしっくりくるものが見つからないので、静的に型付け可能でしかも同期的に処理してるっぽく書けるライブラリを作ってみました。このライブラリを使うと、非同期処理を次のように書けます。

```ts:
var hoge = async.get("hoge.txt");       // get でファイルを ajax で持ってくる
var piyo = async.get("piyo.txt");
var main = async.log(async.concat(hoge, piyo));      // concat で結合、log で出力
async.run(main);                                     // run で実際に実行される
```


こんな感じで、非同期に取得しているはずのデータに対して自然に関数に適用できたりします。このとき、hoge.txt とpiyo.txtの読み込みは並列に走っています。もし直列に読み込みたい場合は、次のようにします。

```ts:
var hoge, piyo;
async.run(
    hoge = async.get("hoge.txt"),
    piyo = async.get("piyo.txt"),
    async.log(async.concat(hoge, piyo))
);
```

式の中では変数の宣言を行えないので、変数の宣言は少し離れた別の行になってしまっているのがちょっと不満です。でもそれ以外は概ね同期処理と似たような見た目になっています。同期的なデータと非同期的なデータを同じように扱えるので、たとえばhoge.txtにほかのファイルのパスが書いてあってhoge.txtのつぎに piyo.txt じゃなくてそれを読みたいという場合は、次のようにします。

```ts:
var hoge = async.get("hoge.txt");
var nyan = async.get(hoge);
var main = async.log(async.concat(hoge, nyan));
async.run(main);
```

これだとさっき並列に読み込んだ時のパターンに似ていますが、もしこれが並列だとすると hoge を読む前に nyan を読んでしまって失敗するということがときどき起こるはずです。でも内部でその辺りをうまく処理してくれて、nyan を読むのに hoge が必要だということから、ちゃんとhogeを先に読んでからnyanを読んでくれます。

先ほどの並列処理では並列に行っているすべての処理が完了してから次の処理に進んでいきますが、複数の処理を並列に行い、そのうちひとつでも完了すれば次の処理に進む、という処理を実現する関数 `sooner` もあります。以下のコードで、hoge.txt のほうがずっと大きいファイルなら piyo.txt の読み込みのほうが早く終わるので、piyo.txt の内容が出力されます。それに対して、piyo.txt のほうがずっと大きければ hoge.txt の内容が出力されます。簡単に実装できたから実装してみただけで、正直この機能は何の役に立つのかよくわかりません。もし使い道が思いついたら教えてください。

```ts:
var hoge = async.get("hoge.txt");
var piyo = async.get("piyo.txt");
var main = async.log(async.sooner(hoge, piyo));
async.run(main);
```

さらに、一時停止のような処理もまるで同期処理のように自然に書けます。次のコードでは、実行するとまず `"hoge"` と出力し、1秒待機してから、そのあと `"piyo"` と出力します。

```ts:
async.run(
    async.log("hoge"),    // "hoge" と出力
    async.wait(1000),     // 1秒待機
    async.log("piyo")     // "piyo" と出力
);
```

コールバックは無いように見えますが、このライブラリが面倒なコールバックをすべて覆い隠してくれるのです(実はライブラリ内部ではコールバックの嵐で大変なことになっています。見たらたぶん吐きます)。しかも TypeScript でガッチガチに静的型付けされていて、ちょっとでも変な使い方をするとすぐコンパイルエラーになるので安心です(JavaScript からでも使えます)。

欠点としては、さっき挙げたような変数の宣言が離れた位置になってしまう場合があるのと、上のコードでいうところの `async.run` で書ける直列な非同期処理の制限が一度に 25 個まで(`async.run`の引数が25個まで)という謎制限があります。この制限はもうすこしライブラリに手を入れればいくらでも緩和できるのですが、とりあえず25個あれば十分かなと思うのでこうなっています。また、デバッガのブレークポイントが仕掛けられないのがつらいです(結構致命的)。また、TypeScript のバグのせいでまだ Node の readFileSync のようなAPI と協調できるようになっていません(バグの回避もできなくはないのですが、面倒なのでバグフィックスを待とうと思います)。

なんじゃこりゃ、いったいどーなってんだ？と思う人もいるとは思いますが、ソースコードは Haskell の Functor, Applicative, Monad あたりの概念がふんだんに使われていて、このあたりの知識がないひとにはちょっとばかり理解するのがたいへんです(Haskellを知っている人向けに説明すると、このライブラリは **非同期処理モナドライブラリ** です。ね？簡単でしょう？)。興味のあるひともいなさそうだしもう疲れたのでこのライブラリの内部までの解説はしませんが、JavaScriptって<del>本当にクソ</del>本当に奥が深いですね。

この謎のライブラリのソースコードはこちら: [kontan/async.ts](https://github.com/kontan/async.ts) (紛らわしいので名前は変えるかも？)

## まとめ

* generators がどのブラウザでも動くようになったら、co を使え。それまでは気合でなんとか持ちこたえろ
* Haskell ってすごい
* 俺のasync.tsは並列と直列が両方そなわり最強に見える

## 参考文献

* [JavaScriptとコールバック地獄](http://techblog.yahoo.co.jp/programming/js_callback/)
* [
jQuery.Deferredを使って楽しい非同期生活を送る方法](http://qiita.com/yuku_t/items/3d1cf51d7ae91305eaaa)
* [結局jQuery.Deferredの何が嬉しいのか分からない、という人向けの小話](http://qiita.com/yuku_t/items/1b8ce6bba133a7eaeb23)
* [爆速でわかるjQuery.Deferred超入門](http://techblog.yahoo.co.jp/programming/jquery-deferred/)
* [仮想パネル: JavaScriptで非同期プログラミングを乗り切る方法](http://www.infoq.com/jp/articles/surviving-asynchronous-programming-in-javascript)
* [進撃の巨人の名言・迷言をまとめようぜｗｗ](http://shingekikyojin.net/archives/28229454.html)
* [ブロントさん名言集](http://www.geocities.jp/burontosan/)
* [ボブ・ロス](http://dic.nicovideo.jp/a/%E3%83%9C%E3%83%96%E3%83%BB%E3%83%AD%E3%82%B9)
* [ゆゆ式](http://www.yuyushiki.net/)